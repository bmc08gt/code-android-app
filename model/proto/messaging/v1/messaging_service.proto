syntax = "proto3";
package code.messaging.v1;
option go_package = "github.com/code-wallet/code-api/genproto/messaging/v1;messaging";
option java_package = "com.codeinc.gen.messaging.v1";
option objc_class_prefix = "CPBMessagingV1";
import "common/v1/model.proto";
import "transaction/v2/transaction_service.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
service Messaging {
    // OpenMessageStream opens a stream of messages. Messages are routed using the
    // public key of a rendezvous keypair derived by both the sender and the
    // recipient of the messages. The sender may be a client or server.
    //
    // Messages are expected to be acked once they have been processed by the client.
    // Ack'd messages will no longer be delivered on future OpenMessageStream calls,
    // and are eligible for deletion from the service. Clients should, however, handle
    // duplicate delivery of messages.
    //
    // Only RequestToGrabBill and RequestToReceiveBill are supported for real time events.
    //
    // For grabbing a bill, the expected flow is as follows:
    //   1. The payment sender creates a payment scan code
    //      (see: https://github.com/code-wallet/code-api/blob/master/spec/scan.md).
    //   2. The payment sender calls `OpenMessageStream` on the rendezvous public key, which is
    //      derived by using sha256(scan_payload) as the keypair seed.
    //   3. The payment recipient scans the code and uses `SendMessage` to send their account ID
    //      back to the sender via the rendezvous public key.
    //   4. The payment sender receives the message, submits the intent, and closes the stream.
    //
    // For receiving a bill of requested value, the expected flow is as follows:
    //   1. The payment recipient uses `SendMessage` to send their account ID and payment amount to
    //      the sender via the rendezvous public key, which is derived by using sha256(scan_payload)
    //      as the keypair seed.
    //   2. The payment recipient calls `OpenMessageStream` on the rendezvous public key to listen
    //      for status messages generated by server. It must ignore the original message it sent as
    //      part of step 1.
    //   3. The payment recipient creates a payment scan code
    //      (see: https://github.com/code-wallet/code-api/blob/master/spec/scan.md).
    //   4. The payment sender calls `PollMessages` on the rendezvous public key. This is ok because
    //      we know the message exists per step 1, and doesn't actually incur a long poll. This is a
    //      required hack because we don't have the infrastructure in place to allow multiple listens
    //      on the same stream, and the recipient needs real-time status updates.
    //   5. The payment sender receives the message (any status messages are ignored), and submits the
    //      intent.
    //   6. The payment recipient sees a success/failure/timeout status message and closes the stream.
    rpc OpenMessageStream(OpenMessageStreamRequest) returns (stream OpenMessageStreamResponse);
    // OpenMessageStreamWithKeepAlive is like OpenMessageStream, but enables a ping/pong
    // keepalive to determine the health of the stream at both the client and server.
    //
    // The keepalive protocol is as follows:
    //   1. Client initiates a stream by sending an OpenMessageStreamRequest.
    //   2. Upon stream initialization, server begins the keepalive protocol.
    //   3. Server sends a ping to the client.
    //   4. Client responds with a pong as fast as possible, making note of
    //      the delay for when to expect the next ping.
    //   5. Steps 3 and 4 are repeated until the stream is explicitly terminated
    //      or is deemed to be unhealthy.
    //
    // Client notes:
    // * Client should be careful to process messages async, so any responses to pings are
    //   not delayed.
    // * Clients should implement a reasonable backoff strategy upon continued timeout failures.
    // * Clients that abuse pong messages may have their streams terminated by server.
    //
    // At any point in the stream, server will respond with messages in real time as
    // they are observed. Messages sent over the stream should not affect the ping/pong
    // protocol timings. Individual protocols for payment flows remain the same, and are
    // documented in OpenMessageStream.
    //
    // Note: This API will enforce OpenMessageStreamRequest.signature is set as part of migration
    //       to this newer protocol
    rpc OpenMessageStreamWithKeepAlive(stream OpenMessageStreamWithKeepAliveRequest) returns (stream OpenMessageStreamWithKeepAliveResponse);
    // PollMessages is like OpenMessageStream, but uses a polling flow for receiving
    // messages. Updates are not real-time and depedent on the polling interval.
    // This RPC supports all message types.
    //
    // This is a temporary RPC until OpenMessageStream can be built out generically on
    // both client and server, while supporting things like multiple listeners.
    rpc PollMessages(PollMessagesRequest) returns (PollMessagesResponse);
    // AckMessages acks one or more messages that have been successfully delivered to
    // the client.
    rpc AckMessages(AckMessagesRequest) returns (AckMesssagesResponse);
    // SendMessage sends a message.
    rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
}

message OpenMessageStreamRequest {
    RendezvousKey rendezvous_key = 1;
    // The signature is of serialize(OpenMessageStreamRequest) using rendezvous_key.
    //
    // todo: Make required once clients migrate
    common.v1.Signature signature = 2;
}

message OpenMessageStreamResponse {
    repeated Message messages = 1;
}

message OpenMessageStreamWithKeepAliveRequest {
    oneof requestOrPong {
        OpenMessageStreamRequest request = 1;
        ClientPong pong = 2;
    }

}

message OpenMessageStreamWithKeepAliveResponse {
    oneof responseOrPing {
        OpenMessageStreamResponse response = 1;
        ServerPing ping = 2;
    }

}

message PollMessagesRequest {
    RendezvousKey rendezvous_key = 1;
    // The signature is of serialize(PollMessagesRequest) using rendezvous_key.
    common.v1.Signature signature = 2;
}

message PollMessagesResponse {
    repeated Message messages = 1;
}

message AckMessagesRequest {
    RendezvousKey rendezvous_key = 1;
    repeated MessageId message_ids = 2;
}

message AckMesssagesResponse {
    Result result = 1;
    enum Result {
        OK = 0;
    }

}

message SendMessageRequest {
    // The message to send. Types of messages clients can send are restricted.
    Message message = 1;
    // The rendezvous key that the message should be routed to.
    RendezvousKey rendezvous_key = 2;
    // The signature is of serialize(Message) using the PrivateKey of the keypair.
    common.v1.Signature signature = 3;
}

message SendMessageResponse {
    Result result = 1;
    enum Result {
        OK = 0;
    }

    // Set if result == OK.
    MessageId message_id = 2;
}

// MessageId identifies a message. It is only guaranteed to be unique when
// paired with a destination (i.e. the rendezvous public key).
message MessageId {
    bytes value = 1;
}

// Request that a pulled out bill be sent to the requested address.
//
// This message type is only initiated by clients.
message RequestToGrabBill {
    // Requestor is the Kin token account on Solana to which a payment should be sent.
    common.v1.SolanaAccountId requestor_account = 1;
}

// Request that a bill of a requested value is created and sent to the requested
// address.
//
// This message type is only initiated by clients.
message RequestToReceiveBill {
    // Requestor is the Kin token account on Solana to which a payment should be sent.
    common.v1.SolanaAccountId requestor_account = 1;
    // The exchange data for the bill value.
    transaction.v2.ExchangeData exchange_data = 2;
}

// A status update on a stream to indicate a scan code was scanned. This can appear
// multiple times for the same stream.
//
// This message type is only initiated by server
message CodeScanned {
    // Estimated scan time as observed by server
    google.protobuf.Timestamp timestamp = 1;
}

// Payment is rejected by the client
//
// This message type is only initiated by clients
message ClientRejectedPayment {
    common.v1.IntentId intent_id = 1;
}

// Intent was submitted via SubmitIntent
//
// This message type is only initiated by server
message IntentSubmitted {
    common.v1.IntentId intent_id = 1;
    transaction.v2.Metadata metadata = 2;
}

// Client has received an aidrop from server
//
// This message type is only initiated by server.
message AirdropReceived {
    // The type of airdrop received
    transaction.v2.AirdropType airdrop_type = 1;
    // Exchange data relating to the amount of Kin and fiat value of the airdrop
    transaction.v2.ExchangeData exchange_data = 2;
    // Time the airdrop was received
    google.protobuf.Timestamp timestamp = 3;
}

message Message {
    // MessageId is the Id of the message. This ID is generated by the
    // server, and will _always_ be set when receiving a message.
    //
    // Server generates the message to:
    //     1. Reserve the ability for any future ID changes
    //     2. Prevent clients attempting to collide message IDs.
    MessageId id = 1;
    // The signature sent from SendMessageRequest, which will be injected by server.
    // This enables clients to ensure no MITM attacks were performed to hijack contents
    // of the typed message. This is only applicable for client-initiated messages.
    common.v1.Signature send_message_request_signature = 3;
    // Next field number is 9
    oneof kind {
        //
        // Section: Client requests
        //
        RequestToGrabBill     request_to_grab_bill     = 2;
        RequestToReceiveBill  request_to_receive_bill  = 5;
        //
        // Section: Payment status updates (only supported through RequestToReceiveBill flows atm)
        //
        CodeScanned           code_scanned             = 6;
        ClientRejectedPayment client_rejected_payment  = 7;
        IntentSubmitted       intent_submitted         = 8;
        //
        // Section: Airdrops
        //
        AirdropReceived       airdrop_received         = 4;
    }

}

message RendezvousKey {
    bytes value = 1;
}

message ServerPing {
    // Timestamp the ping was sent on the stream, for client to get a sense
    // of potential network latency
    google.protobuf.Timestamp timestamp = 1;
    // The delay server will apply before sending the next ping
    google.protobuf.Duration ping_delay = 2;
}

message ClientPong {
    // Timestamp the Pong was sent on the stream, for server to get a sense
    // of potential network latency
    google.protobuf.Timestamp timestamp = 1;
}

